# Crypto(HMAC)

Данный проект представляет собой реализацию клиент-серверного взаимодействия с использованием WebSocket и HMAC для обеспечения целостности сообщений. Сервер проверяет HMAC сообщения, отправляемого клиентом, и отвечает на него, указывая, валидно ли сообщение.

## Структура проекта

Проект состоит из двух частей:
- Серверная часть: Принимает сообщения от клиента и проверяет их подлинность с помощью HMAC.
- Клиентская часть: Отправляет сообщения на сервер и получает ответ о их валидности.

## Работа кода

### Серверная часть

Сервер реализован с использованием библиотеки websockets. Он создает асинхронный обработчик, который:
1. Принимает сообщения от клиента.
2. Извлекает сообщение и HMAC из входных данных.
3. Генерирует ожидаемый HMAC на основе полученного сообщения и заранее определенного ключа.
4. Сравнивает ожидаемый HMAC с HMAC, полученным от клиента.
5. Отправляет ответ клиенту ("Valid message" или "Invalid message").

### Клиентская часть

Клиент также использует библиотеку websockets. Он выполняет следующие шаги:
1. Подключается к серверу.
2. Формирует сообщение и генерирует для него HMAC на основе заранее определенного ключа.
3. Отправляет сообщение вместе с HMAC на сервер.
4. Ожидает он ответа от сервера и выводит его в консоль.

## Запуск проекта

Чтобы запустить проект, выполните следующие шаги:

1. Убедитесь, что у вас установлен Python и библиотека websockets. Если библиотека не установлена, вы можете установить её с помощью команды:
   
   pip install websockets
   

2. Сохраните серверную часть кода в файл, например HMAC_server.py, и клиентскую часть в файл HMAC_client.py.

3. Запустите сервер в одном терминале:
   
   python server.py
   

4. Запустите клиент в другом терминале:
   
   python client.py
   

## Примечания

1. Убедитесь, что вы запускаете сервер и клиент в одной директории.
2. При необходимости модифицируйте значение переменной shared_key для улучшения безопасности.
3. Вы можете изменять сообщение в клиентской части для тестирования различных сценариев.
________________________________________________________________________________________________________________________________________
## Scaner

1. Импорт модуля socket: Этот модуль позволяет работать с сетевыми сокетами.

2. Функция scan_ports:
    - Принимает список целей (IP-адресов) и диапазон портов.
    - Для каждой цели выполняется цикл, который перебирает указанный диапазон портов.
    - Для каждого порта создается сокет, который пытается установить соединение с целевым адресом на указанном порту.
    - Если соединение успешно (результат равен 0), выводится информация о том, что порт открыт.

3. Главная программа:
    - Определяет список целей для сканирования.
    - Задает диапазон портов от 1 до 1024.
    - Вызывает функцию scan_ports для выполнения сканирования.

## Запуск скрипта

Для запуска скрипта сохраните его в файл, например, port_scanner.py, и выполните команду в терминале:

python port_scanner.py
________________________________________________________________________________________________________________________________________
##Sniff

## Описание

Для отслеживания только TCP SYN пакетов с использованием фильтров в Scapy, нам нужно установить соответствующий BPF-фильтр. Для TCP SYN пакетов нужно использовать фильтр, который определяет, что TCP-флаг SYN установлен, а ACK не установлен.

## Пояснение кода

- Фильтр: tcp[tcpflags] == tcp-syn - этот фильтр определяет, что мы ищем только пакеты, где установлен флаг SYN и не установлен флаг ACK. Этот фильтр использует синтаксис BPF, который является стандартом для фильтрации пакетов в сетевых приложениях.

- Функция sniff: 
    - iface='wlp58s0' – это имя сетевого интерфейса, который вы используете.
    - filter='' – здесь мы ставим наш фильтр для отслеживания только SYN пакетов.
    - prn=lambda x: x.summary() – это функция, которая вызывается для каждого захваченного пакета, выводя краткое резюме о нём.

## Запуск скрипта

Сохраните этот код в файл, например, tcp_syn_sniffer.py, и выполните его в терминале с правами администратора:

sudo python tcp_syn_sniffer.py
